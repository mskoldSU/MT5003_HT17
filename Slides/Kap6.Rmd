---
title: "Statistisk inferensteori <br> Bayesiansk statistik <br> (H & B, Kapitel 6)"
author: "Martin Sköld"
output:
  ioslides_presentation:
    logo: SU_logo_CMYK.png
    incremental: no
    css: slides.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
handout <- FALSE
```
```{r, echo = handout}
# Data och förberedelse

set.seed(1) # För att kunna reproducera

# Luftkonditionering, tider mellan fel (från Cox, D.R. and Snell, E.J. (1981))
ac <- c(90, 10, 60, 186, 61, 49, 14, 24, 56, 20, 79, 84, 44, 59, 29, 118, 25, 156, 310, 76, 26, 44, 23, 62, 130, 208, 70, 101)

# Transformera Rs datamaterial "trees", svenska enheter och namn
träd <- trees
colnames(träd) <- c("Diameter", "Höjd", "Volym")
träd <- transform(träd, Radie = Diameter / 39.37 / 2) # Tum till meter
träd <- transform(träd, Höjd = Höjd / 3.28) # Fot till meter
träd <- transform(träd, Volym = Volym / 3.28^3) # Kubikfot till kubikmeter
träd <- subset(träd, select = -Diameter) # Ta bort diameter

```

```{r, echo = handout}
## Funktioner

# Weibull-likelihood
L.weib <- Vectorize( # Möjliggör elementvis beräkning i (alpha, beta)
  function(alpha, beta, data){
    # Bestämmer likelihood givet en vektor observationer från Weibull(alpha, beta)
    # Argument:
    #     (alpha, beta): parametervärde (eventuellt vektorer)
    #     data: observationsvektor
    # Utdata:
    #     Likelihoodfunktionens värden i (alpha, beta)
    #
    L.out <- prod(dweibull(data, shape = alpha, scale = 1 / beta))
    if (is.nan(L.out))
      L.out <- 0
    return(L.out)
  }
  , vectorize.args = c("alpha", "beta"))
l.weib <- Vectorize( # Möjliggör elementvis beräkning i theta
  function(alpha, beta, data){
    # Bestämmer loglikelihood givet en vektor observationer från Weibull(alpha, beta)
    # Argument:
    #     (alpha, beta): parametervärde (eventuellt vektorer)
    #     data: observationsvektor
    # Utdata:
    #     loglikelihoodfunktionens värden i (alpha, beta)
    #
    l.out <- sum(log(dweibull(data, shape = alpha, scale = 1 / beta)))
    return(l.out)
  }
  , vectorize.args = c("alpha", "beta"))
# Score-vektor för Weibulllikelihood
S.weib <- function(alpha, beta, data){
    # Bestämmer scorevektor givet en vektor observationer från Weibull(alpha,beta)
    # Argument:
    #     (alpha,beta): parametervärden
    #     data: observationsvektor
    # Utdata:
    #     Scorefunktionens värden i (alpha,beta)
    #
    S.out <- c(sum(1 / alpha+log(data * beta) * (1 - (data * beta)^alpha)),
               alpha * sum(1 - (data * beta)^alpha) / beta)
    return(S.out)
}
# Fisherinformation för Weibulllikelihood
I.weib <- function(alpha, beta, data){
    # Bestämmer informationsmatris givet en vektor observationer från Weibull(alpha,beta)
    # Argument:
    #     (alpha,beta): parametervärden
    #     data: observationsvektor
    # Utdata:
    #     informationsmatrisens värden i (alpha,beta)
    #
    I11 <- sum(1 / alpha^2 + log(data * beta)^2 * (data * beta)^alpha)
    I12 <- sum((data * beta)^alpha + alpha * log(data * beta) * (data * beta)^alpha - 1) / beta
    I22 <- alpha * sum((alpha - 1) * (data * beta)^alpha + 1) / beta^2
    I.out<-cbind(c(I11, I12), c(I12, I22))
    return(I.out)}
# Likelihood för modellen Volym_i=beta*Höjd_i*Radie_i^2+epsilon_i
# med epsilon_i oberoende Normal(0, sigma2)
P.träd <- Vectorize( # Möjliggör elementvis beräkning i (beta, sigma2)
  function(beta, sigma2, data){
    # Bestämmer likelihood i regressionsmodell för volymer av trädstammar
    # Argument:
    #     (beta, sigma2): parametervärde (eventuellt vektorer)
    #     data: data.frame innehållander variablerna Volym, Radie och Höjd
    # Utdata:
    #     Likelihoodfunktionens värden i (beta, sigma2)
    #    
    L.out <- with(data, prod(dnorm(Volym, beta * Radie^2 * Höjd, sd = sqrt(sigma2)))) / sigma2
    return(L.out)
  },
  vectorize.args = c("beta", "sigma2")
)
```

## Frekventistisk och subjektiv sannolikhet

Låt $A$ beteckna en händelse, $P(A)$ är: 

- **Frekventist**: Händelsen $A$ är ett möjligt utfall av ett upprepbart slumpmässigt experiment, $P(A)$ fås som empiriska andelen experiment där $A$ inträffar.

- **Subjektiv**: $P(A)$ är ett personligt mått på hur troligt det är att $A$ inträffar.

## Frekventistisk och Bayesiansk statistik

Vi vill uttala oss om värdet på okänd parameter $\theta_0\in\Theta$

- **Frekventist**: Innan jag observerat data vet jag bara att $\theta_0\in\Theta$.

- **Bayesian**: Innan jag observerat data kan min kunskap om värdet på $\theta_0$ beskrivas av en sannolikhetstäthet $p_\theta(\cdot)$, *apriorifördelningen*.

## Frekventistisk och Bayesiansk statistik

Vi vill uttala oss om värdet på okänd parameter $\theta_0\in\Theta$ efter att ha observerat $x$, en realisering av $X\sim P_{\theta_0}$

- **Frekventist**: Min skattning av $\theta_0$ är $\hat{\theta}(x)$, osäkerheten i min metod beskrivs av $\hat{\theta}(X)$, $X\sim P_\theta$.

- **Bayesian**: Min kunskap om värdet på $\theta_0$ är nu uppdaterad till den betingade tätheten $p_{\theta|X}(\cdot|x)$ för $\theta|X=x$, *aposteriorifördelningen*.

## Bayes formel

Om vi tolkar $p_{X|\theta}(x|\theta)$ som den betingade tätheten för $X|\theta$ kan vi bestämma aposteriorifördelningen

$$
p_{\theta|X}(\cdot|x)=\frac{p_{X|\theta}(x|\cdot)p_\theta(\cdot)}{p_X(x)}\propto p_{X|\theta}(x|\cdot)p_\theta(\cdot)
$$

## Exempel: Kvalitetskontroll apriorifördelning

```{r, echo = handout}
theta <- seq(0, .3, length.out = 1000)
plot(theta, dbeta(theta, 2, 30), type = "l", yaxs = "i", xaxs = "i", ylim = c(0, 18),
     xlab = expression(theta), ylab = expression(p(theta)))
abline(v = 0.1, lty = 3)
```

## Exempel: Kvalitetskontroll aposteriorifördelning

```{r, echo = handout}
theta <- seq(0, .3, length.out = 1000)
plot(theta, dbeta(theta, 5, 77), type = "l", yaxs="i", xaxs = "i", ylim = c(0, 18),
     xlab = expression(theta), ylab = expression(paste("p(", theta, "|", x, ")")))
lines(theta, dbeta(theta, 2, 30), lty = 2)
abline(v = 0.1, lty = 3)
```

## Exempel: Kvalitetskontroll

$P(\theta>0.1)$
```{r, echo = TRUE}
1 - pbeta(0.1, 2, 30)
```


$P(\theta>0.1|X=3)$
```{r, echo = TRUE}
1 - pbeta(0.1, 5, 77
          )
```


## Exempel: Livslängder apriorifördelning

```{r, echo = handout}
theta <- seq(0, .03, length.out = 1000)
plot(theta, dgamma(theta, 2, 100), type = "l",
     xlab = expression(theta), ylab = expression(paste("p(", theta, "|", x, ")")))
```

## Exempel: Livslängder aposteriorifördelning

```{r, echo = handout}
theta <- seq(0, .03, length.out = 1000)
plot(theta, dgamma(theta, 30, sum(ac) + 100), type = "l",
     xlab = expression(theta), ylab = expression(paste("p(", theta, "|", x, ")")))
lines(theta, dgamma(theta, 2, 100), lty = 2)
```

## Exempel: Livslängder, lägesmått

```{r, echo = handout}
theta <- seq(0, .03, length.out = 1000)
plot(theta, dgamma(theta, 30, sum(ac) + 100), type = "l",
     xlab = expression(theta), ylab = expression(paste("p(", theta, "|", x, ")")))
mean <- 30 / (sum(ac) + 100)
median <- qgamma(0.5, 30, sum(ac) + 100)
mode <- 29 / (sum(ac) + 100)
abline(v = mean, lty = 1)
abline(v = median, lty = 2)
abline(v = mode, lty = 3)
```

## Exempel: Livslängder, kredibilitetsintervall
```{r, echo = handout, fig.height=3}
theta <- seq(0, .03, length.out = 1000)
plot(theta, dgamma(theta, 30, sum(ac) + 100), type = "l",
     xlab = expression(theta), ylab = expression(paste("p(", theta, "|", x, ")")))
abline(v = qgamma(c(0.025, 0.975), 30, sum(ac)+ 100), lty = 3)
```
```{r, echo = TRUE}
qgamma(c(0.025, 0.975), 30, sum(ac) + 100)
```


# Val av apriorifördelning

## Konjungerande familj

<div class="boxed">
**Definition:** (H & B, definition 6.5)
En familj fördelningar $\mathcal{G}$ säges vara konjungerande med avseende på en likelihoodfunktion $L(\theta)=p(x|\theta)$ om $p(\theta|x)\in\mathcal{G}$ när $p(\theta)\in\mathcal{G}$.
</div>

## Jeffreys prior

<div class="boxed">
**Definition:** (H & B, definition 6.7)
Givet en likelihood $L(\theta)$ ges Jeffreys apriorifördelning av
$$
p(\theta)\propto \sqrt{J(\theta)}.
$$
</div>


## Jeffreys prior, Binomiallikelihood

```{r, echo = handout}
theta <- seq(0, 1, length.out = 1000)
plot(theta, dbeta(theta, 1/2, 1/2), type = "l",
     xlab = expression(theta), ylab = expression(p(theta)))
```

## Vektorvärda parametrar

- Frektventister pluggar in...

- Bayesianer integrerar ut:

$$
p(\theta|x)=\int p(\theta, \eta|x)\, d\eta.
$$

## Trädvolymer, aposterioriförd

```{r, echo = handout}
# Figur: Likelihood och log-likelihood för regressionsmodell trädvolymer
beta <- seq(1.15, 1.29, length.out = 100)
sigma2 <- seq(0.0025, .009, length.out = 100)
# Beräkna aposterioriförd över en matris av parametervärden
P.träd.mat <- outer(beta, sigma2, FUN = P.träd, data = träd)
# Plotta aposterioriförd
contour(beta, sigma2, P.träd.mat,
        xlab = expression(beta), ylab = expression(sigma^2))
```

## Trädvolymer, aposterioriförd för $\beta$

```{r, echo = handout}
post.beta <- Vectorize(function(beta, data){
  n <- nrow(data)
  post.out <- with(data, (sum((Volym - beta * Radie^2 * Höjd)^2/2))^(-n/2))
  return(post.out)
}, vectorize.args = "beta")
plot(beta, post.beta(beta, träd), type = "l", xlab = expression(beta), ylab = "")

```

## Monte-Carlo metoder

- Svårt att integrera ut analytiskt.

- Om vi kan simulera från $\phi=(\theta, \eta)\sim p_\phi(\cdot|x)$ kan vi även simulera från $\theta\sim p_\theta(\cdot|x)$.

- Svårt att simulera direkt från $p_\phi(\cdot|x)$ men lätt att simulera en Markov-process med $p_\phi(\cdot|x)$ som stationär fördelning...

## Metropolis-Hastings (Random Walk)

Välj startvärde $z_0$.

Upprepa för $i=1, ..., N$:

- Låt $z^*=z_{i-1}+\epsilon_i$, $\epsilon_i\sim N(0,\sigma^2)$.

- Om $f(z^*)/f(z_{i-1})> u_i$, $u_i\sim Likf[0,1]$ låt $z_i=z^*$, annars $z_i=z_{-1}$

$z_1, ..., z_N$ är nu en dragning från en Markov-process med stationär fördelning $f$. 

## MH, Weibull

```{r, echo = TRUE}
post <- function(theta){L.weib(theta[1], theta[2], data = ac)}
N <- 10000 #Antal iterationer
theta <- matrix(nrow = N, ncol = 2)
theta[1,] <- c(1, 0.01) #Startvärde
sigma <- c(0.1, 0.001) #Steglängd
for (i in 2:N){
  theta.star <- theta[i-1,] + rnorm(2) * sigma
  if (post(theta.star) / post(theta[i-1,]) > runif(1))
    theta[i,] <- theta.star
  else
    theta[i,] <- theta[i-1,]
}

```


## MH, Weibull

```{r, echo = FALSE, fig.height=4}
par(mfrow = c(2, 1), mar = c(1,1,1,1) + 1)
plot(theta[,1], type = "l", ylab = "", xlab = expression(alpha))
plot(theta[,2], type = "l", ylab = "", xlab = expression(beta))
```

## MH, Weibull

```{r, echo = FALSE, fig.height=4}
par(mfrow = c(1,2))
hist(theta[,1], 50, xlab=expression(alpha), prob = TRUE, main = "")
hist(theta[,2], 50, xlab=expression(beta), prob = TRUE, main = "")
```

## MH, Weibull

Sannolikheten att medeltiden mellan fel är större än 100 timmar:
```{r, echo = TRUE}
mean(1 / theta[,2] > 100)
```
Sannolikheten att ett aggregat håller mer än 100 timmar:
```{r, echo = TRUE}
T <- rweibull(N, theta[, 1], scale = 1 / theta[, 2])
mean(T > 100)
```


## MH, för långa steg

```{r, echo = handout, warning= FALSE}
theta[1,] <- c(1, 0.01) #Startvärde
sigma <- c(0.1, 0.001)*100 #Steglängd
for (i in 2:N){
  theta.star <- theta[i-1,] + rnorm(2) * sigma
  if (post(theta.star) / post(theta[i-1,]) > runif(1))
    theta[i,] <- theta.star
  else
    theta[i,] <- theta[i-1,]
}
par(mfrow = c(2, 1), mar = c(1,1,1,1) + 1)
plot(theta[,1], type = "l", ylab = "", xlab = expression(alpha))
plot(theta[,2], type = "l", ylab = "", xlab = expression(beta))
```

## MH, för korta steg

```{r, echo = handout, warning= FALSE}
theta[1,] <- c(1, 0.01) #Startvärde
sigma <- c(0.1, 0.001)/100 #Steglängd
for (i in 2:N){
  theta.star <- theta[i-1,] + rnorm(2) * sigma
  if (post(theta.star) / post(theta[i-1,]) > runif(1))
    theta[i,] <- theta.star
  else
    theta[i,] <- theta[i-1,]
}
par(mfrow = c(2, 1), mar = c(1,1,1,1) + 1)
plot(theta[,1], type = "l", ylab = "", xlab = expression(alpha))
plot(theta[,2], type = "l", ylab = "", xlab = expression(beta))
```

## Sammanfattning, Bayesian vs Frekventist

- Som frekventist slipper du ange apriorifördelning, men måste ofta förlita dig på asymptotiska resultat.

- Som Bayesian slipper du hänvisa till asymptotik, men måste lita på din apriorifördelning.